\documentclass[a4paper]{article}
\usepackage{hyperref}
\usepackage{fullpage} % Package to use full page
\usepackage{tikz} % Package for drawing

\usepackage{fancyhdr, graphicx, amssymb}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\include{pythonlisting}

\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[bottom]{footmisc}
\usepackage{titling}
\usepackage[margin=0.6in]{geometry}
\usepackage{titlesec}
\titlespacing*{\section}{0pt}{0.5\baselineskip}{0.3\baselineskip}
\titlespacing*{\subsection}{0pt}{0.5\baselineskip}{0.3\baselineskip}

\hypersetup{
    colorlinks=true, 
    urlcolor=blue
}

\setlength{\droptitle}{-8em}   % This is your set screw
\begin{document}



\section{Scoring Function Overview}
The scoring function that I have designed builds upon the suggestions in the assignment brief, and to the best of my knowledge has strong biological intuition. The score function is made up of three key parts. 
\subsection{Convex Gap Scores}
It is well-known that single mutation events - such as translocation and duplication - may create alignment gaps of different sizes. Therefore, there is a biological need to treat such gaps as a single entity, as opposed to individually penalising each successive \textit{indel}. Two protein sequences may be relatively similar but differ only at a certain interval, and we don't want to excessively penalise such an alignment. Affine gap scores have been used extensively in industry, and are often the gap score method of choice when partnered with the \textit{BLOSUM} score matrices. An affine gap score combines a constant 'gap-opening' penalty (favouring shorter gaps) with an additional penalty that is linear in the number of further residues in the gap (favouring fewer, larger gaps). Typically, the 'gap-opening' penalty is an order of magnitude larger than the additional penalty ((10, 1) for BLOSUM-62), and thus such a gap-score scheme goes some way to reducing the penalty given to large gaps. However, it has been shown empirically that an affine gap length is too rigid for use in a biological context\footnote{Sung, Wing-Kin (2011). \textit{Algorithms in Bioinformatics : A Practical Introduction. CRC Press. pp. 42?47}}. Moreover, other studies have shown that the distribution of \textit{indels} typically follows a power law (logarithmic) distribution\footnote{\url{http://elbo.gs.washington.edu/courses/GS_559_11_wi/slides/4A-Sequence_comparison-ScoreMatrices.pdf}}. Therefore, I have opted to use a convex gap penalty model, in which each additional space in a gap contributes less to the gap weight than the previous space. The model I propose for (internal) gap scores is:
\begin{center}
$P_g \cdot \ln(n) $
\end {center}
where $P_g$ is the gap opening penalty, and $n$ is the length of the gap. 

\subsection{Trailing, Internal and Terminating Gap Score Differentiation}
The second key feature of my scoring function is the implementation of different gap-scoring parameters for trailing, internal, and terminating gaps. It has been shown empirically, through optimization techniques, that the optimal model for matches often has opening and terminal gap-open penalties that are approximately half of the gap-open penalty used for internal gaps\footnote{\url{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC548345/}}. Intuitively, this makes sense - the query sequence could merely be a translation of the database sequence, and should not be excessively penalised. Therefore, the model I propose for trailing and terminating gap sequences is:
\begin{center}
$\frac{P_g}{2} \cdot \ln(n) $
\end {center}
where $P_g$ is the gap opening penalty, and $n$ is the length of the gap.
 It is worth noting that this feature of the scoring function only applies to the global alignment case, as all (biologically-imitating) score functions assign negative scores to gaps, and so leading and trailing gaps would never be included in a local alignment. 
 
\subsection{Codon Match Reward}
A codon is a set of three bases (technically three nucelotides) which codes for a certain amino acid. This sequence of contiguous triplets defines a protein's functionality, and the codons hold the key to the translation of genetic information for the synthesis of proteins. Therefore, I believe matches of (multiples of) three contiguous bases should be rewarded with a score that is higher than the summation of the scores of the individual matches. I propose a multiplicative scoring system, where:
\begin{center}
$Adjusted\;Score = C(t) \cdot Additive\;Score $,
\end {center}
where $t$ is the number of codons matched consecutively. This codon scoring scheme could be extend further and the entire alignment scoring could be implemented on the codon level, using the empirical scoring matrices found here\footnote{\url{https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-6-134}}.

\subsection{Further Features}
Further features that could be included to more accurately mimic biologically reality include:
\begin{itemize}
\item Take into account the position within the current codon. Point mutation frequencies are not evenly distributed over the three positions within a codon, so different scoring matrices could be used for each of the three positions
\item Have gap-specific indel scores. There is evidence to suggest that specific residue types are preferred in gap regions\footnote{Wrabl JO, Grishin NV (2004). "Gaps in structurally similar proteins: towards improvement of multiple sequence alignment" }, and so once a gap has been opened a secondary scoring matrix could be used for the following residues in the gap.
\item Score specific mutation events individually. For example, in the case of a duplicated amino acid (a triplet/codon of three bases), the penalty induced for the insertion of three \textit{indels} could be reduced if the three residues are identical to previous triplet of residues: as in the case of AAC\textbf{ACG}TCG and AAC\textbf{ACGACG}TCG, for example. 

\end{itemize}

\section{Scoring Function Implementation}
\subsection{Parameters}
As I have described an array of different features above, I shall implement only the convex gap score penalty, and the codon match reward function. The parameters required are therefore:
\begin{itemize}
\item The gap-opening penalty: $P_g = -10$ (as is often used with some of the BLOSUM matrices)
\item The codon match reward function: $ C(t) = \begin{cases} 
      1 + (0.1)t & 0 \leq t \leq 10 \\
      2 & t > 10 \\
      \end{cases} $ where $t = \lfloor{m/3}\rfloor$, and $m$ is the number of contiguously matched residues. This function increasingly rewards longer contiguous matches of codons. 
\item The scoring matrix: $a =  \bigl( \begin{smallmatrix}1 & -1 & -2\\ -1 & 2 & -4\\ -2 & -4 & 3\end{smallmatrix}\bigr)$, indexed in the usual way for the alphabet $\Sigma = \{A, B, C\}$. In the absence of a real scoring matrix such as PAM or BLOSUM, I shall use the score matrix given in the assignment brief. In reality, the score matrix would be alphabet-specific, and would be found empirically using the probabilistic model discussed in lectures. 

\end{itemize}
\subsection{Algorithm}

\begin{algorithm}[H]
\SetAlgoLined
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

\Input{A query sequence $Q$, and a database sequence $D$, both formed from the alphabet $\Sigma = \{A, B, C\}$}
\Output{An array of [Alignment Score, The indices of $Q$, The indices of $D$]}
\KwData{\\
score\_matrix $\leftarrow [[1, -1, -2], [-1, 2, -4], [-2, -4, 3]]$\\
$P_g \leftarrow -4$\\
$C(t) \leftarrow 1 + (0.1 \cdot t) \: if \; 0 \leq t \leq 10 \: else \; 2$

}
\BlankLine
 $align\_matrix \leftarrow$ zero\_array($m + 1, n + 1$)\;
 $pointers \leftarrow$ zero\_array($m + 1, n + 1$)\;
 \BlankLine
 \For{i, l in $\mathrm{enumerate(}$D$\mathrm{)}$}{
 	\For{j, k in $\mathrm{enumerate(}$Q$\mathrm{)}$}{
		$left\_gap, a, b \leftarrow$ backtrack($i, j, left$)\;
		$up\_gap, c, d \leftarrow$ backtrack($i, j, up$)\;
		$diag\_gap \leftarrow$ backtrack($i, j, diag$)\;
		\BlankLine
		$left\_score \leftarrow align\_matrix[a, b] + (P_g \cdot \ln(left\_gap + 2))$\;
		$up\_score \leftarrow align\_matrix[c, d] + (P_g \cdot \ln(up\_gap + 2))$\;
		$diag\_score \leftarrow align\_matrix[i, j] + (score\_matrix[l, k] \; \cdot \; $C($\lfloor{\frac{diag\_gap}{3}}\rfloor$)\;
		\BlankLine
		$scores \leftarrow$ array($0, left\_score, diag\_score, up\_score$)\;
		$align\_matrx[i + 1, j + 1] \leftarrow $ max($scores$)\;
		$pointers[i + 1, j + 1] \leftarrow $ argmax($scores$)\;
		
	}
 }

\BlankLine
\KwRet{ $\mathrm{[max(}$scores$\mathrm{))}$, $\mathrm{generate\_indices(}$pointers, $\mathrm{argmax(}$scores$\mathrm{))]}$}

 \caption{Local Sequence Alignment with Convex Gap Penalties and Codon Rewards}
\end{algorithm}
\end{document}
















